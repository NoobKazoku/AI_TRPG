# QFramework（项目架构框架）- 负责游戏整体架构
使用场景：
游戏状态管理：主菜单、游戏中、暂停、设置等状态切换
场景管理：场景加载、切换、注册（SceneKey枚举就是这里用的）
UI管理：UI页面的注册、显示、隐藏（UiKey枚举）
数据模型：游戏存档、设置数据、玩家数据等
命令系统：游戏内的各种操作命令（如你看到的ChangeVolumeCommand等）
事件系统：游戏内各模块间的通信
具体例子：
```
// 使用QFramework切换场景
this.SendCommand(new LoadSceneCommand(SceneKey.AITRPG));

// 使用QFramework管理游戏状态  
this.GetSystem<IStateMachineSystem>().ChangeTo<PlayingState>();

// 使用QFramework处理设置
this.SendCommand(new SaveSettingsCommand());
```
# Microsoft Agent Framework - 负责AI智能代理
使用场景：
AI对话逻辑：处理用户输入，生成AI回复
工具调用：让AI能够调用外部工具或API
记忆管理：维护对话历史和上下文
多Agent协作：如果有多个AI角色需要协作
复杂推理：需要AI进行逻辑推理、规划等
具体例子：
```
// 在你的AI_TRPG.cs中，SendMessage方法里调用Agent Framework
private async Task<string> ProcessMessageWithAI(string userMessage)
{
    // 这里集成Microsoft Agent Framework
    var agent = new YourAgent();
    return await agent.ProcessAsync(userMessage);
}
```
## 分工原则：
QFramework负责"游戏框架层"
游戏循环、状态机、场景切换
UI显示/隐藏、输入处理
数据持久化、设置管理
同步操作（立即执行的游戏逻辑）
Microsoft Agent Framework负责"AI业务层"
对话理解、内容生成
工具调用、外部API交互
复杂的AI决策逻辑
异步操作（需要等待AI响应的操作）
在你的AI_TRPG项目中的具体应用：
AI_TRPG Controller（使用QFramework）

处理UI交互（按钮点击、输入框）
管理聊天消息的显示/隐藏
调用AI服务获取回复
切换到其他游戏场景
AIAgentService（使用Microsoft Agent Framework）

封装AI对话逻辑
处理TRPG游戏规则
管理游戏世界状态
生成剧情和NPC对话
两者协作方式：


```
// AI_TRPG.cs (QFramework Controller)
public async void UserSendMessage()
{
    // QFramework: 显示用户消息
    AddUserMessage(InputBox.Text);
    
    // 调用AI服务 (Microsoft Agent Framework)
    string aiResponse = await _aiAgentService.ProcessMessage(InputBox.Text);
    
    // QFramework: 显示AI回复
    AddAIMessage(aiResponse);
}
```
简单记忆：

QFramework = 游戏的"身体"（骨架、肌肉、神经系统）
Microsoft Agent Framework = 游戏的"大脑"（思考、决策、创造力）
这样分工既保持了架构清晰，又充分发挥了两个框架的优势！

https://qf.readthedocs.io/zh-cn/latest/QFramework_v1.0_Guide/02_architecture/10_architecture_spec_and_recommended_usage.html